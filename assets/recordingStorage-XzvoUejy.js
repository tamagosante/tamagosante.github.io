var b=Object.defineProperty;var u=(m,t,e)=>t in m?b(m,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):m[t]=e;var w=(m,t,e)=>u(m,typeof t!="symbol"?t+"":t,e);const p="watcher-recordings-db";const c="recordings",d="metadata";class y{constructor(){w(this,"recordings",new Map);w(this,"dbPromise");w(this,"loadingPromise");this.dbPromise=this.initDB(),this.loadingPromise=this.loadFromStorage()}async waitForInitialization(){await this.loadingPromise}async initDB(){return new Promise((t,e)=>{const r=indexedDB.open(p,1);r.onupgradeneeded=o=>{const i=o.target.result;i.objectStoreNames.contains(c)||i.createObjectStore(c),i.objectStoreNames.contains(d)||i.createObjectStore(d)},r.onsuccess=o=>{t(o.target.result)},r.onerror=o=>{e("IndexedDB error: "+o.target.error)}})}async loadFromStorage(){try{const e=(await this.dbPromise).transaction([d,c],"readonly"),r=e.objectStore(d),o=e.objectStore(c),i=r.getAll(),g=await new Promise((n,s)=>{i.onsuccess=()=>n(i.result),i.onerror=()=>s(i.error)});for(const n of g){const s=o.get(n.id),h=new Promise((l,S)=>{s.onsuccess=()=>l(s.result),s.onerror=()=>S(s.error)});try{const l=await h;l&&this.recordings.set(n.id,{id:n.id,name:n.name,blob:l,timestamp:new Date(n.timestamp),duration:n.duration,size:n.size,transcription:n.transcription})}catch(l){console.warn(`Failed to load recording ${n.id}:`,l)}}}catch(t){console.error("Failed to load recordings from IndexedDB:",t),await this.migrateFromLocalStorage()}}async migrateFromLocalStorage(){try{const t=localStorage.getItem("watcher-recordings");if(t){const e=JSON.parse(t);for(const r of e){const o=atob(r.blobData),i=new Array(o.length);for(let s=0;s<o.length;s++)i[s]=o.charCodeAt(s);const a=new Uint8Array(i),g=new Blob([a],{type:r.mimeType}),n={id:r.id,name:r.name,blob:g,timestamp:new Date(r.timestamp),duration:r.duration,size:r.size,transcription:r.transcription||void 0};this.recordings.set(r.id,n)}await this.saveToStorage(),localStorage.removeItem("watcher-recordings"),console.log("Migrated recordings from localStorage to IndexedDB")}}catch(t){console.error("Failed to migrate from localStorage:",t)}}async saveToStorage(){try{const e=(await this.dbPromise).transaction([d,c],"readwrite"),r=e.objectStore(d),o=e.objectStore(c),i=Array.from(this.recordings.values());for(const a of i){const g={id:a.id,name:a.name,timestamp:a.timestamp.toISOString(),duration:a.duration,size:a.size,mimeType:a.blob.type,transcription:a.transcription};r.put(g,a.id),o.put(a.blob,a.id)}await new Promise((a,g)=>{e.oncomplete=()=>a(),e.onerror=()=>g(e.error)})}catch(t){throw console.error("Failed to save recordings to IndexedDB:",t),t}}async saveRecording(t,e){await this.waitForInitialization();const r=`recording-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,o=new Date,i=t.size,a={id:r,name:e||`Recording ${o.toLocaleString()}`,blob:t,timestamp:o,size:i,transcription:void 0};return this.recordings.set(r,a),await this.saveToStorage(),a}async getRecording(t){return await this.waitForInitialization(),this.recordings.get(t)}async getAllRecordings(){return await this.waitForInitialization(),Array.from(this.recordings.values()).sort((t,e)=>e.timestamp.getTime()-t.timestamp.getTime())}async updateTranscription(t,e){await this.waitForInitialization();const r=this.recordings.get(t);return r?(r.transcription=e,await this.saveToStorage(),!0):!1}async deleteRecording(t){await this.waitForInitialization();const e=this.recordings.delete(t);if(e)try{const o=(await this.dbPromise).transaction([d,c],"readwrite"),i=o.objectStore(d),a=o.objectStore(c);i.delete(t),a.delete(t),await new Promise((g,n)=>{o.oncomplete=()=>g(),o.onerror=()=>n(o.error)})}catch(r){throw console.error("Failed to delete recording from IndexedDB:",r),r}return e}async clearAllRecordings(){await this.waitForInitialization(),this.recordings.clear();try{const e=(await this.dbPromise).transaction([d,c],"readwrite"),r=e.objectStore(d),o=e.objectStore(c);r.clear(),o.clear(),await new Promise((i,a)=>{e.oncomplete=()=>i(),e.onerror=()=>a(e.error)})}catch(t){throw console.error("Failed to clear recordings from IndexedDB:",t),t}}async getStorageUsage(){await this.waitForInitialization();const t=Array.from(this.recordings.values());return{count:t.length,totalSize:t.reduce((e,r)=>e+r.size,0)}}}const I=new y;export{I as r};
