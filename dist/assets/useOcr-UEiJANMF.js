var v=Object.defineProperty;var C=(f,e,r)=>e in f?v(f,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):f[e]=r;var y=(f,e,r)=>C(f,typeof e!="symbol"?e+"":e,r);import{r as c}from"./react-vendor-BOZDwKwV.js";import{O as R}from"./index-Cmkaodfg.js";const F={type:"object",properties:{extractedText:{type:"string",description:"The complete text extracted from the image via OCR. Preserve formatting, line breaks, and structure as much as possible."},detectedLanguage:{type:"string",description:"The primary language detected in the text (e.g., 'English', 'Vietnamese', 'Chinese', 'Mixed')"},confidence:{type:"string",description:"Confidence level of the OCR extraction (e.g., 'high', 'medium', 'low')"}},required:["extractedText"]};async function O(f,e="qwen3-vl:latest",r){const t=new R(e),a=`You are an expert OCR (Optical Character Recognition) system.

Your task is to extract ALL text visible in the provided image with maximum accuracy.

Instructions:
1. Extract every piece of text you can see in the image
2. Preserve the original formatting, line breaks, and text structure as much as possible
3. If the text contains multiple columns, extract left to right, top to bottom
4. Include any numbers, symbols, or special characters you see
5. Detect the primary language of the text
6. Assess your confidence in the extraction accuracy

Be thorough and precise. Extract everything you can see.`;try{return await t.generateStructuredCompletion(a,F,e,{images:[f],system:"You are a precise OCR system. Always respond in valid JSON format with the extracted text.",signal:r})}catch(s){throw console.error("OCR error:",s),new Error(`OCR failed: ${s instanceof Error?s.message:"Unknown error"}`)}}class M{constructor(){y(this,"defaultModel","granite3.2-vision")}async processImageFile(e,r){const t=this.validateImageFile(e);if(!t.valid)throw new Error(`Invalid image file: ${t.error}`);const a=await this.fileToBase64(e);return this.processBase64Image(a,r)}async processImageBlob(e,r){if(!e.type.startsWith("image/"))throw new Error(`Invalid blob type: ${e.type}. Expected image/*`);const t=await this.blobToBase64(e);return this.processBase64Image(t,r)}async processBase64Image(e,r){const t=Date.now(),a=this.cleanBase64String(e);if(!this.isValidBase64(a))throw new Error("Invalid base64 string");let s=a;if(r!=null&&r.downscale){const l=(r==null?void 0:r.downscaleFactor)??.5;s=await this.downscaleBase64Image(a,l)}const u=(r==null?void 0:r.model)??this.defaultModel;try{const l=await O(s,u,r==null?void 0:r.signal),n=Date.now()-t;return{...l,processingTime:n,modelUsed:u,timestamp:new Date}}catch(l){throw l instanceof Error&&l.name==="AbortError"?new Error("OCR operation was cancelled"):l}}async processDataUrl(e,r){if(!e.startsWith("data:image/"))throw new Error('Invalid data URL. Must start with "data:image/"');return this.processBase64Image(e,r)}async processImageUrl(e,r){try{const t=await fetch(e,{signal:r==null?void 0:r.signal});if(!t.ok)throw new Error(`Failed to fetch image: ${t.statusText}`);const a=await t.blob();return this.processImageBlob(a,r)}catch(t){throw t instanceof Error&&t.name==="AbortError"?new Error("Image fetch was cancelled"):t}}validateImageFile(e){if(!e.type.startsWith("image/"))return{valid:!1,error:`Invalid file type: ${e.type}. Expected image/*`};const r=10*1024*1024;return e.size>r?{valid:!1,error:`File too large: ${(e.size/1024/1024).toFixed(2)}MB. Maximum allowed: 10MB`}:{valid:!0}}fileToBase64(e){return new Promise((r,t)=>{const a=new FileReader;a.onload=()=>{const u=a.result.split(",")[1];r(u)},a.onerror=()=>{t(new Error("Failed to read file"))},a.readAsDataURL(e)})}blobToBase64(e){return new Promise((r,t)=>{const a=new FileReader;a.onload=()=>{const u=a.result.split(",")[1];r(u)},a.onerror=()=>{t(new Error("Failed to read blob"))},a.readAsDataURL(e)})}cleanBase64String(e){return e.includes(",")?e.split(",")[1]:e}isValidBase64(e){try{return/^[A-Za-z0-9+/]*={0,2}$/.test(e)?(typeof atob<"u"&&atob(e.substring(0,100)),!0):!1}catch{return!1}}async downscaleBase64Image(e,r){return new Promise((t,a)=>{const s=new Image;s.onload=()=>{const u=Math.floor(s.width*r),l=Math.floor(s.height*r),n=document.createElement("canvas");n.width=u,n.height=l;const w=n.getContext("2d");if(!w){a(new Error("Failed to get canvas context"));return}w.drawImage(s,0,0,u,l),n.toBlob(i=>{if(!i){a(new Error("Failed to create blob"));return}const h=new FileReader;h.onload=()=>{const p=h.result.split(",")[1];t(p)},h.onerror=()=>{a(new Error("Failed to read downscaled image"))},h.readAsDataURL(i)},"image/jpeg",.9)},s.onerror=()=>{a(new Error("Failed to load image for downscaling"))},s.src=`data:image/jpeg;base64,${e}`})}setDefaultModel(e){this.defaultModel=e}getDefaultModel(){return this.defaultModel}}function D(){const[f,e]=c.useState(null),[r,t]=c.useState(!1),[a,s]=c.useState(null),[u,l]=c.useState(null),n=c.useRef(null),w=c.useRef(new M);c.useEffect(()=>()=>{n.current&&n.current.abort()},[]);const i=c.useCallback(async(d,...m)=>{n.current&&n.current.abort(),n.current=new AbortController,t(!0),s(null),e(null),l(null);try{const o=await d(w.current,n.current.signal,...m);return e(o),l(o.processingTime),o}catch(o){const g=o instanceof Error?o.message:"OCR processing failed";return s(g),null}finally{t(!1),n.current=null}},[]),h=c.useCallback((d,m)=>i((o,g)=>o.processImageFile(d,{...m,signal:g})),[i]),b=c.useCallback((d,m)=>i((o,g)=>o.processImageBlob(d,{...m,signal:g})),[i]),p=c.useCallback((d,m)=>i((o,g)=>o.processBase64Image(d,{...m,signal:g})),[i]),x=c.useCallback((d,m)=>i((o,g)=>o.processDataUrl(d,{...m,signal:g})),[i]),E=c.useCallback((d,m)=>i((o,g)=>o.processImageUrl(d,{...m,signal:g})),[i]),I=c.useCallback(()=>{n.current&&(n.current.abort(),n.current=null,t(!1),s("Operation cancelled"))},[]),B=c.useCallback(()=>{e(null),s(null),l(null),t(!1),n.current&&(n.current.abort(),n.current=null)},[]);return{result:f,isProcessing:r,error:a,processingTime:u,processFile:h,processBlob:b,processBase64:p,processDataUrl:x,processUrl:E,cancel:I,reset:B}}export{D as u};
